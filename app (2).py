import warnings
from flask import Flask
from flask import request
from ui_streamlit_v5_turbo import *
from flask import json
from werkzeug.exceptions import HTTPException
from collections import OrderedDict
import json
from datetime import datetime
from pandas.api.types import is_datetime64_any_dtype as is_datetime
from flask_cors import CORS
from google.cloud import bigquery
import nltk
from nltk.corpus import words

nltk.download('words')
english_words = words.words()

app=Flask(__name__)
CORS(app)
warnings.filterwarnings("ignore")

job_config = bigquery.QueryJobConfig(default_dataset="dmgcp-del-136.demo_data_20231221")
bq = bigquery.Client() 

PROJECT = 'dmgcp-del-136'
LOCATION = 'us-central1'

@app.errorhandler(HTTPException)
def handle_exception(e):
    """Return JSON instead of HTML for HTTP errors."""
    response = e.get_response()
    if e.code == 404:
        description = "server not found"
    elif e.code == 403:
        description = "permission denied"
    elif e.code == 500:
        description = "server side error"
        
    response.data = json.dumps({
        "code": e.code,
        "name": e.name,
        "description": description,
    })
    response.content_type = "application/json"
    return response

@app.route('/view_table',methods=['GET'])
def show_table():
    query = "SELECT * FROM dmgcp-del-136.demo_data_20231221"
    df = bq.query(query.upper(),job_config).to_dataframe()
    df = df.sample(10)
    return df.to_dict(orient = 'records')
    

@app.route('/generate_insights',methods=["POST"])
def generate_sql_insights():
    query = request.json["query"]
    llm_type = request.json["llm_type"]
    
    query_words = query.split(" ")
    validity=query_words[0].lower()
    if validity not in english_words:
        return "enter a valid query"
    
    if llm_type =='openai': 
        sql_query = get_sql_query_openai(query,llm_type)
                
    elif llm_type =='palm2' or llm_type =='llama':
        MODEL_NAME = 'codechat-bison@002'
        llm = ChatVertexAI(project=PROJECT,location=LOCATION,model_name=MODEL_NAME,
                           temperature=0.0,max_output_tokens=2048)
        sql_query = get_sql_query_vertexai(query,llm)
                
    elif llm_type =='gemini-pro': 
        MODEL_NAME = "gemini-pro"
        sql_query = get_sql_query_geminiai(query,MODEL_NAME)
        
    df = bq.query(sql_query.upper(),job_config).to_dataframe()

    for column in df.columns:
        if df[column].dtype == float:
            df[column] = df[column].round(2)

    def is_datetime(column):
        return pd.api.types.is_datetime64_ns_dtype(column.dtype)
    
    for column in df.columns:
        if is_datetime(df[column]):
            df[column] = df[column].dt.date
        
    result = df.astype(str).to_dict(orient = 'records')
    
    columns = df.columns.values.tolist() 
    md_map = df.dtypes.to_dict()
    
    var_prompt = f"""Here is an sql query: {sql_query}, i will run this on the table with the schema: {md_map} and further i would also want to visualize the results. I want you to give me the X-axis for the graph i will plot by analyzing the columns asked in the query . Only use the column names given in the schema below and dont change them. Just give the column name, i dont want any explanation.
    IMPORTANT: If the generated columns: {columns} are not in the schema, just return the independent variable from the list of columns {columns}.
    IMPORTANT: I want to use your output directly in my server so it very important you just give me the column_name according to the schema and no additional details given, not even a statement required, just the column_name as the output is required. Make sure you only give one coumn as x axis and not multiple. And just the column name is required. """

    graph_prompt=f""" Imagine you are a data analyst and you were asked to plot a graph for the following dataframe: {df} which was generated by the following sql command: {sql_query}. What kind of graph do you think would best suit the situation. Use the standard conventions for the type of graph name. IMPORTANT: I want to use your output directly in my server so it very important you just give me the type of graph as a single word answer and no additional text. Your answer should only contain a single word describing the type of raph and nothing else. """


    describe_prompt = f"""Assume you are a data analyst look into these values generated for my question which was '{query}' and give me a top 5 insights of this data in bullet points on seperate lines . values:{df}, metadeta:{md_map}. Just print the bullet points in separate lines and nothing else. If the number used in the description you provide are too large, use words like millions, thousands and billions instead of writing the entire number in the output. if the number is greater than 10000, use the above convention i mentioned. But dont change the figures got in the values."""
    
    textual_summaries = describe_bot(describe_prompt, llm_type)
    
    x_axis = describe_bot(var_prompt, llm_type)
    
    typeOfGraph = describe_bot(graph_prompt,llm_type)
    
    sql_query = sql_query.replace('\n', '') 
    textual_summary = textual_summaries.split('\n')
    
    if len(textual_summary)> 0:
        summaries=[]
        for summary_bullet in textual_summary:
            if len(summary_bullet) > 0:
                summaries.append(summary_bullet[1:].strip(' *'))          
    else:
         summaries=["No summary generated"]
        
    prompts = sample_gen(df,llm_type)
    sample_prompts = []
    prompts_lst = prompts.split('\n')
    
    if len(prompts_lst) > 0:
        for i, prompt in enumerate(prompts.split('\n')):
            if len(prompt) > 0:
                sample_prompts.append(prompt.strip('* '))         
    else:
         sample_prompts = ["No follow up prompts"]
            
    metadata={'columns':columns, 'x_axis':x_axis}
    
    ans = {'result': result,'metadata':metadata, 'sql_query':sql_query,'textual_summary':summaries, 'followup_prompts':sample_prompts,"x-axis":x_axis, "typeOFgraph":typeOfGraph}
    
    return ans

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=8501, debug = True)